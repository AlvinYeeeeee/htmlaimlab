My project is a completely html based aimlab. It is very easy to make an aimlab with engines such as Unity, because it has a 3D environment in it. What I am trying to do is to make an html based aimlab. That means I need to create a 3D environment using html.

I am aware that there is a library called 3D in JavaScript. However, if I use this library, it is no different then using Unity. Therefore, I choose to not to use 3D but instead achieve the 3D effects through rotation and transformation.

To begin with, I first made a couple of squares and named them “floor” (s). After that, I transform that with: rotateX(x rad), translateY(y px), translateZ(z px). Basically, this mimics the change in the depth of the camera so that it can the floors can be transformed in a way that it looks like a plane in 3D place. I looked up the appropriate values online. After that, I found out that 1 square floor is not working well, so I put nine squares put together. It worked.

After that, I started working on how to mimic the movement of the camera. This can be achieved through rotateX(x rad), rotateY(y rad) and translateZ(z px), each representing the x, y, and z axis. When we try to move the camera, we only need to examine the x and y. We assign the x and y to be vertical and horizontal, and z to be into the screen or out of the screen. After that, we make an arena in css and allow it to have: style="transform: rotateX(0rad) rotateY(0rad)" so that initially the camera is facing the front. Now it is the tricky part: I write a function rotateArena and camera so that when we find out the current location of the cursor (the x and y value) is different from the previous location of the cursor, we calculate the distance through finding the distance and the sensitivity and do arena.style.transform = `rotateX(${x}rad) rotateY(${y}rad)`;. This mimics the process of moving the camera.

After that, I start placing enemies into the 3D environment. I initially assign nine positions, forming a 3*3 grid, and then assign its x, y, and z position, and do style="top: ${yPos}px; left: ${xPos}px; transform: translateZ(${zPos}px); so it can connect with css enemies and locate the red blocks.

After that, I face the challenge to check whether the camera is facing the enemies, so that when I click the mouse, it counts as a score. Remember the camera mentioned before? I record the range of the two angles when a camera is facing one specific enemies through console.log, so I have nine groups of values. So if the mouse is clicked and the camera’s angle is within the range, it counts as a successful shot. However, the problem that arises from that is that if the size of the website changes, the angle will change as well. It took me a long time to find out the problem (because when I am trying to find the angles, I turned on F12, which makes the size of the page different; and when I turned off F12, the size of the page changes and the aimlab no longer works). To solve this problem, I embedded the html that holds this problem into a new html through iframe, and restricts the size of the embedded website. With that implemented, I solved the aim problem, and also by coincidence ensure that this game will work on different devices.

My next step is to count the scores and accuracy. The way I do this is to first have a shoot and killEnemy function in JavaScript. Since now I know how to see whether the shot lands on the enemy, all I need is to trigger shot by left click, achieved through EventListener and set a timer of 60 seconds. After each shot, shot++, and after each killEnemy, score++, and the accuracy will be calculated through score/shot dynamically. After that, I use getElementById to podcast these values to the html page, and display them live in the website. At the end, the shots, score, accuracy, and time will be recorded, and the JavaScript will podcast these values to the flask server - the second important feature of my program.

I used flask to allow me to store the scores of different players, compare them and hence create a leader board and history page. When the timer of the game ends, I use fetch to call /endpage in app.py with the method of ‘POST’. This will assign the values to the website so I can display them. I created a score.db with two tables: the first users table having id, username, hashed_password, high_score and high_accuracy, and the second history table having history_id, user_id (to link to the first table), shots, score, accuracy, and time, and I will work on this database through app.py. After the timer reaches 0, with fetch I send the data to app.py, and app.py will renew the database: add a new row in the history table, and testing whether the new score is higher than the current user’s high_score and/or high_accuracy with the max function. I choose to include high_score and high_accuracy in the first table is because this can make the leader board implemented more easily.

So now I have the game running, and the game is able to renew the database after every single game. After that, I made several pages such as profile that stores the current user’s highest score and accuracy and history; leader board that shows two leader boards: one according to high score and one according to high accuracy; login and register and logout page. I copied some of the styles and app.py and helpers from psets homepage and finance. You can check out the details in my source code.

So, this is CS50 AimLab. I hope you love it!
